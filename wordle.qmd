---
title: "wordle"
format: html
editor: visual
---

##Exercise 4

Wordle Challenge

Loading in my packages and data sets. Preliminary

```{r}
library(tidyverse)
library(ggplot2)
f<-"https://raw.githubusercontent.com/difiore/ada-datasets/main/collins-scrabble-words-2019.txt" #load my dataset
d<- read_csv(f, col_names = TRUE)
e<- "https://raw.githubusercontent.com/difiore/ada-datasets/main/google-10000-english-usa-no-swears.txt" #load my second data set
g<- read_csv(e, col_names = TRUE)
```

Starting the code for the Wordle Challenge. Step 1: Creating function and variables

```{r}
# Custom function to load a dictionary file
load_dictionary <- function(df){
  
  words <- as.character(df[[1]])   # FORCE character vector
  words <- trimws(words)
  words <- words[words != ""]
  
  words <- toupper(words)          # Normalize case early
  
  return(words)
}
# Creating my two variables
valid_list <- load_dictionary(d)
solution_list <- load_dictionary(g)

# Checking structure of my variables
str(valid_list)
str(solution_list)

```

Step 2: Winnowing

```{r}
solution_list<- intersect(solution_list, valid_list)
length(solution_list) #checks how many words are in the vector
```

Step 2 Question: How many words are in your updated solution_list vector? 8,336 words are in the winnowed solution_list vector.

Step 3: Custom Function

```{r}
pick_solution <- function(solution_list, word_length = 5) {
  
  # [1] removes all words from solution_list that are not 5 letters in length
  filtered_words <- solution_list[nchar(solution_list) == word_length]
  
  # [2] randomly chooses a single word from those that remain
  chosen_word <- sample(filtered_words, size = 1)
  
  # [3] splits that word into a vector of single-character elements
  split_word <- strsplit(chosen_word, "")[[1]]
  
  return(split_word)
}

#assign variable
solution <- pick_solution(solution_list) 
```

Step 4: Final Functions and Play Game!

```{r}
#| eval: false
# Helper function
evaluate_guess <- function(guessVec, answerVec){
  
  wordLength <- length(answerVec)
  resVec <- rep("-", wordLength)
  
  answerCopy <- answerVec
  
  # First pass — exact matches
  for(i in 1:wordLength){
    if(guessVec[i] == answerCopy[i]){
      resVec[i] <- "*"
      answerCopy[i] <- "-"
    }
  }
  
  # Second pass — yellow matches
  for(i in 1:wordLength){
    if(resVec[i] != "*"){
      idx <- match(guessVec[i], answerCopy)
      if(!is.na(idx)){
        resVec[i] <- "+"
        answerCopy[idx] <- "-"
      }
    }
  }
  
  return(paste(resVec, collapse = ""))
}
#checking it works
evaluate_guess(strsplit("early", "")[[1]], 
              strsplit("later", "")[[1]])
# Main game function
play_wordle <- function(solution, valid_list, num_guesses = 6, wordLength = 5){
  
  # Ensure solution is a single string, not a vector of letters 
  if (length(solution) > 1L) solution <- paste(solution, collapse = "")
  solution <- toupper(as.character(solution))
  valid_list <- toupper(valid_list)
  solutionVec <- strsplit(solution,"")[[1]]   # now guaranteed length == wordLength
  
  # Game rules
  cat("Welcome to Wordle!\n")
  cat("You have", num_guesses, "chances to guess a", wordLength, "letter word.\n\n")
  
  # Track data
  lettersLeft <- LETTERS
  guess_history <- c()
  feedback_history <- c()
  
  guessCnt <- 0
  
  while(guessCnt < num_guesses){
    
    # Print letters left 
    cat('[1] "Letters left: ', paste(lettersLeft, collapse=" "), '"\n', sep = "")
    
    guessCnt <- guessCnt + 1
    
    guess <- toupper(readline(
      paste0("Enter guess ", guessCnt, ": ")
    ))
    
    # Validate guess
    while(TRUE){
      if(nchar(guess) == wordLength && guess %in% valid_list){
        break
      }
      guess <- toupper(readline(
        paste0("Invalid. Enter a ", wordLength, " letter valid word: ")
      ))
    }
    
    guessVec <- strsplit(guess,"")[[1]]
    
    # Show the guess 
    cat('[1] "', paste(guessVec, collapse = " "), '"\n', sep = "")
    
    # Evaluate guess 
    feedback <- evaluate_guess(guessVec, solutionVec)
    
    # Normalize feedback to be a single 5-char string 
    if (length(feedback) > 1L) {
      feedback <- paste(feedback, collapse = "")
    }
    if (length(feedback) == 1L && nchar(feedback) == 1L) {
      feedback <- strrep(feedback, wordLength)   # "-" -> "-----"
    }
    
    # Store history 
    guess_history <- c(guess_history, guess)
    feedback_history <- c(feedback_history, feedback)
    
    # Display feedback spaced with icons
    cat('[1] "', paste(strsplit(feedback, "")[[1]], collapse = " "), '"\n', sep = "")
    
    # Update lettersLeft: remove only gray letters (not present in solution) 
    fb_chars <- strsplit(feedback, "")[[1]]
    gray_mask <- fb_chars == "-"
    if (any(gray_mask)) {
      letters_to_remove <- unique(guessVec[gray_mask])
      lettersLeft <- setdiff(lettersLeft, letters_to_remove)
    }
    
    # Win condition
    if (feedback == strrep("*", wordLength)){
      cat("You won!\n")
      #returns count, guesses, and feedback
      return(list(
  Guess_Count = guessCnt,
  Guess_History = guess_history,
  Feedback_History = feedback_history
))
    }
  }
  
  # Loss condition
  cat("\nYou lose!. The word was:", solution, "\n")
      #returns count, guesses, and feedback
  return(list(
  Guess_Count = guessCnt,
  Guess_History = guess_history,
  Feedback_History = feedback_history
))
}
#play the game!!!
solution <- pick_solution(solution_list) #generates solution
play_wordle(solution, valid_list) #starts game
```
